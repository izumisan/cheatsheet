# C++11

C++11で追加・変更点のうち、よく使いそうなものを覚書

__cplusplusマクロ値は`201103L`

# `auto`（型推論）

# `decltype`（型の取得）

# 範囲for文（range-based for loop）

```cpp
for ( const auto& item : array ) { doSomething(); }
for ( auto&& item : array ) { doSomething(); }
```

# 初期化リスト（initializer lists）

# 左辺値・右辺値・ムーブ

# ラムダ式

クロージャ（関数オブジェクトのクラス）を定義する構文

`auto`又は`std::function`でラムダ式を保持できる.

## 構文

 `[キャプチャリスト](パラメータリスト) mutable 例外仕様 属性 -> 戻り値の型 { 関数の本体 }`

```cpp {.line-numbers}
// 何もしないラムダ式
auto hoge = []{};

// 引数の()や->は省略できる
auto hello = []{ std::cout << "Hello World" << std::endl; };

// int plus( int a, int b ) 関数をラムダ式で表現
// ラムダ式で戻り値の型を省略した場合は、return文から型推論される
auto plus = []( int a, int b ){ return a + b };
int result = plus( 2, 3 );
```

## キャプチャ

|記法|説明|
|---|---|
|`[&]`|参照キャプチャ|
|`[=]`|コピーキャプチャ|
|`[&x]`|変数xを参照キャプチャ|
|`[x]`|変数xをコピーキャプチャ|
|`[this]`|メンバ変数を参照キャプチャ|
|`[&, x]`|変数xはコピー、その他は参照キャプチャ|
|`[=, &x]`|変数xは参照、その他はコピーキャプチャ|
|`[this, &x]`|メンバ変数を参照、変数xを参照キャプチャ|

# `nullptr`

# `constexpr`

# `default`, `delete`宣言

# 移譲コンストラクタ（delegating constructors）

初期化子から同じクラスの別のコンストラクタを呼び出す.

```cpp {.line-numbers}
class Foo
{
public:
  Foo()
    : Foo(123)  // 移譲コンストラクタ
  {}
  Foo( const int value )
    : m_value(value)
  {}
private:
  int m_value;
```

# メンバ変数の初期化

# 継承コンストラクタ（inheriting constructors）

# `override`, `final`

# `enum class`（スコープ付き列挙型）

# 戻り値の後置構文

- autoの部分が->で指定した型に置き換えられる
- 戻り値を後置することで、パラメータリストを参照して戻り値の型を指定することができる
- 「-> 戻り値の型」の部分は、「trailing return types」と呼ばれるらしい

```cpp {.line-numbers}
auto plus( int a, int b ) -> int
{
    return a + b;
}

// パラメータリストを参照して戻り値の型を指定することができる.
auto plus2( int a, int b ) -> decltype( a + b )
{
    return a + b;
}

auto returnVoidFunction() -> void
{
    doSomething();
}
```

# Raw文字列リテラル（`R"(xxx)"`）

エスケープシーケンスが無視される文字列リテラル.

```cpp {.line-numbers}
auto&& path = R"(C:\path\to\file)";

auto&& json = R"({
  "foo" : "fuga",
  "hoge" : 1.23
})";
```

# utf-8文字列リテラル（`u8"xxx"`）

# `std::begin()`, `std::end()`（先頭・末尾イテレータを取得する非メンバ関数）

# `std::all_of()`, `std::any_of()`, `std::none_of()`

# `std::minmax()`, `std::minmax_element()`（最小値と最大値を同時に取得する関数）

- `std::minmax()`は要素を指定、`std::minmax_element()`はイテレータを指定する。
- 戻り値は、最小値・最大値のstd::pair<T, T>型
- `<algorithm>`ヘッダ

```cpp {.line-numbers}
auto&& minmax = std::minmax( { 7, 3, 1, 5, 9 } );
std::cout << "min: " << minmax.first << std::endl;
std::cout << "max: " << minmax.second << std::endl;

std::vector<int> list = { 6, 2, 0, 4, 8 };
auto&& minmaxIt = std::minmax_element( list.begin(), list.end() );
std::cout << "min: " << *(minmaxIt.first) << std::endl;
std::cout << "max: " << *(minmaxIt.second) << std::endl;
```

# `std::shared_ptr<T>`, `std::unique_ptr<T>`（スマートポインタ）

# `std::to_string()`（数値を文字列に変換する関数）

```cpp
std::string&& str = std::to_string( 123 );
```

# `std::stoi()`, `std::stof()`, `std::stod()`（文字列を数値に変換する関数）

```cpp {.line-numbers}
auto&& i = std::stoi( "456" );  // int
auto&& f = std::stof( "4.56" );  // float
auto&& d = std::stod( "4.56" );  // double

d = std::stod( "0.12345e2" );  // 指数表現
i = std::stoi( "0111", nullptr, 2 );  // 2進数
i = std::stoi( "0xFF", nullptr, 16 );  // 16進数
```

# `std::tuple`（タプルオブジェクト）

# `std::system_error`（システムエラー例外クラス）

# `<chrono>`（時間ユーティリティライブラリ）

# `<type_traits>`（型操作ライブラリ）

# `<regex>`（正規表現ライブラリ）

# `<random>`（乱数ライブラリ）

# GCCでC++11を有効にする

次のオプションを指定する

|ver|option|
|---|---|
|4.3～4.6|-std=c++0x|
|4.7以降|-std=c++11|

# 参考

- [C++11 - Wikipedia](https://ja.wikipedia.org/wiki/C%2B%2B11)
- [C++11 - cpprefjp C++日本語リファレンス](https://cpprefjp.github.io/lang/cpp11.html)
